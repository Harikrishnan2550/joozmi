"use client";

import { useEffect, useRef, useState } from "react";
import { mat4, quat, vec2, vec3 } from "gl-matrix";

/* =========================
   SHADERS
========================= */

const discVertShaderSource = `#version 300 es
precision highp float;

uniform mat4 uWorldMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uProjectionMatrix;
uniform vec3 uCameraPosition;
uniform vec4 uRotationAxisVelocity;

in vec3 aModelPosition;
in vec2 aModelUvs;
in mat4 aInstanceMatrix;

out vec2 vUvs;
out float vAlpha;
flat out float vInstanceId;

#define PI 3.141593

void main() {
    vec4 worldPosition = uWorldMatrix * aInstanceMatrix * vec4(aModelPosition, 1.0);

    vec3 centerPos = (uWorldMatrix * aInstanceMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
    float radius = length(centerPos.xyz);

    vec3 rotationAxis = uRotationAxisVelocity.xyz;
    float rotationVelocity = min(0.15, uRotationAxisVelocity.w * 15.0);

    vec3 stretchDir = normalize(cross(centerPos, rotationAxis));
    vec3 relativeVertexPos = normalize(worldPosition.xyz - centerPos);

    float strength = dot(stretchDir, relativeVertexPos);
    float invAbsStrength = min(0.0, abs(strength) - 1.0);
    strength = rotationVelocity * sign(strength) * abs(invAbsStrength * invAbsStrength * invAbsStrength + 1.0);

    worldPosition.xyz += stretchDir * strength;
    worldPosition.xyz = radius * normalize(worldPosition.xyz);

    gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;

    vAlpha = smoothstep(0.5, 1.0, normalize(worldPosition.xyz).z) * 0.9 + 0.1;
    vUvs = aModelUvs;
    vInstanceId = float(gl_InstanceID);
}
`;

const discFragShaderSource = `#version 300 es
precision highp float;

uniform sampler2D uTex;
uniform float uItemCount;
uniform float uAtlasSize;

in vec2 vUvs;
in float vAlpha;
flat in float vInstanceId;

out vec4 outColor;

void main() {
    float itemIndex = mod(vInstanceId, uItemCount);

    float cellsPerRow = uAtlasSize;
    float cellX = mod(itemIndex, cellsPerRow);
    float cellY = floor(itemIndex / cellsPerRow);

    vec2 cellSize = vec2(1.0) / vec2(cellsPerRow);
    vec2 cellOffset = vec2(cellX, cellY) * cellSize;

    vec2 st = vec2(vUvs.x, 1.0 - vUvs.y);
    st = st * cellSize + cellOffset;

    vec4 color = texture(uTex, st);
    color.a *= vAlpha;

    outColor = color;
}
`;

/* =========================
   GEOMETRY HELPERS
========================= */

class Face {
  constructor(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
}

class Vertex {
  constructor(x, y, z) {
    this.position = vec3.fromValues(x, y, z);
    this.normal = vec3.create();
    this.uv = vec2.create();
  }
}

class Geometry {
  constructor() {
    this.vertices = [];
    this.faces = [];
  }

  addVertex(...args) {
    for (let i = 0; i < args.length; i += 3) {
      this.vertices.push(new Vertex(args[i], args[i + 1], args[i + 2]));
    }
    return this;
  }

  addFace(...args) {
    for (let i = 0; i < args.length; i += 3) {
      this.faces.push(new Face(args[i], args[i + 1], args[i + 2]));
    }
    return this;
  }

  get lastVertex() {
    return this.vertices[this.vertices.length - 1];
  }

  subdivide(divisions = 1) {
    const midPointCache = {};
    let f = this.faces;

    for (let div = 0; div < divisions; ++div) {
      const newFaces = new Array(f.length * 4);

      f.forEach((face, ndx) => {
        const mAB = this.getMidPoint(face.a, face.b, midPointCache);
        const mBC = this.getMidPoint(face.b, face.c, midPointCache);
        const mCA = this.getMidPoint(face.c, face.a, midPointCache);

        const i = ndx * 4;
        newFaces[i + 0] = new Face(face.a, mAB, mCA);
        newFaces[i + 1] = new Face(face.b, mBC, mAB);
        newFaces[i + 2] = new Face(face.c, mCA, mBC);
        newFaces[i + 3] = new Face(mAB, mBC, mCA);
      });

      f = newFaces;
    }

    this.faces = f;
    return this;
  }

  spherize(radius = 1) {
    this.vertices.forEach((vertex) => {
      vec3.normalize(vertex.normal, vertex.position);
      vec3.scale(vertex.position, vertex.normal, radius);
    });
    return this;
  }

  get data() {
    return {
      vertices: this.vertexData,
      indices: this.indexData,
      normals: this.normalData,
      uvs: this.uvData,
    };
  }

  get vertexData() {
    return new Float32Array(
      this.vertices.flatMap((v) => Array.from(v.position))
    );
  }

  get normalData() {
    return new Float32Array(this.vertices.flatMap((v) => Array.from(v.normal)));
  }

  get uvData() {
    return new Float32Array(this.vertices.flatMap((v) => Array.from(v.uv)));
  }

  get indexData() {
    return new Uint16Array(this.faces.flatMap((f) => [f.a, f.b, f.c]));
  }

  getMidPoint(ndxA, ndxB, cache) {
    const cacheKey = ndxA < ndxB ? `k_${ndxB}_${ndxA}` : `k_${ndxA}_${ndxB}`;
    if (Object.prototype.hasOwnProperty.call(cache, cacheKey)) {
      return cache[cacheKey];
    }
    const a = this.vertices[ndxA].position;
    const b = this.vertices[ndxB].position;
    const ndx = this.vertices.length;
    cache[cacheKey] = ndx;
    this.addVertex(
      (a[0] + b[0]) * 0.5,
      (a[1] + b[1]) * 0.5,
      (a[2] + b[2]) * 0.5
    );
    return ndx;
  }
}

class IcosahedronGeometry extends Geometry {
  constructor() {
    super();
    const t = Math.sqrt(5) * 0.5 + 0.5;
    this.addVertex(
      -1, t, 0,   1, t, 0,   -1, -t, 0,   1, -t, 0,
      0, -1, t,   0, 1, t,   0, -1, -t,   0, 1, -t,
      t, 0, -1,   t, 0, 1,   -t, 0, -1,   -t, 0, 1
    ).addFace(
      0,11,5,  0,5,1,  0,1,7,  0,7,10,  0,10,11,
      1,5,9,  5,11,4,  11,10,2,  10,7,6,  7,1,8,
      3,9,4,  3,4,2,  3,2,6,  3,6,8,  3,8,9,
      4,9,5,  2,4,11,  6,2,10,  8,6,7,  9,8,1
    );
  }
}

class DiscGeometry extends Geometry {
  constructor(steps = 56, radius = 1) {
    super();
    steps = Math.max(4, steps);

    const alpha = (2 * Math.PI) / steps;

    this.addVertex(0, 0, 0);
    this.lastVertex.uv[0] = 0.5;
    this.lastVertex.uv[1] = 0.5;

    for (let i = 0; i < steps; ++i) {
      const x = Math.cos(alpha * i);
      const y = Math.sin(alpha * i);
      this.addVertex(radius * x, radius * y, 0);
      this.lastVertex.uv[0] = x * 0.5 + 0.5;
      this.lastVertex.uv[1] = y * 0.5 + 0.5;

      if (i > 0) {
        this.addFace(0, i, i + 1);
      }
    }
    this.addFace(0, steps, 1);
  }
}

/* =========================
   WEBGL HELPERS
========================= */

function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);

  if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    return shader;
  }

  console.error("Shader compile error:", gl.getShaderInfoLog(shader));
  gl.deleteShader(shader);
  return null;
}

function createProgram(gl, shaderSources, transformFeedbackVaryings, attribLocations) {
  const program = gl.createProgram();

  [gl.VERTEX_SHADER, gl.FRAGMENT_SHADER].forEach((type, ndx) => {
    const shader = createShader(gl, type, shaderSources[ndx]);
    if (shader) gl.attachShader(program, shader);
  });

  if (transformFeedbackVaryings) {
    gl.transformFeedbackVaryings(program, transformFeedbackVaryings, gl.SEPARATE_ATTRIBS);
  }

  if (attribLocations) {
    for (const attrib in attribLocations) {
      gl.bindAttribLocation(program, attribLocations[attrib], attrib);
    }
  }

  gl.linkProgram(program);
  if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
    return program;
  }

  console.error(gl.getProgramInfoLog(program));
  gl.deleteProgram(program);
  return null;
}

function makeBuffer(gl, sizeOrData, usage) {
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, sizeOrData, usage);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  return buf;
}

function makeVertexArray(gl, bufLocNumElmPairs, indices) {
  const va = gl.createVertexArray();
  gl.bindVertexArray(va);

  for (const [buffer, loc, numElem] of bufLocNumElmPairs) {
    if (loc === -1) continue;
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.enableVertexAttribArray(loc);
    gl.vertexAttribPointer(loc, numElem, gl.FLOAT, false, 0, 0);
  }

  if (indices) {
    const indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
  }

  gl.bindVertexArray(null);
  return va;
}

function resizeCanvasToDisplaySize(canvas) {
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  const displayWidth = Math.round(canvas.clientWidth * dpr);
  const displayHeight = Math.round(canvas.clientHeight * dpr);
  const needResize = canvas.width !== displayWidth || canvas.height !== displayHeight;
  if (needResize) {
    canvas.width = displayWidth;
    canvas.height = displayHeight;
  }
  return needResize;
}

function createAndSetupTexture(gl, minFilter, magFilter, wrapS, wrapT) {
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
  return texture;
}

/* =========================
   ARCBALL CONTROL
========================= */

class ArcballControl {
  constructor(canvas, updateCallback) {
    this.canvas = canvas;
    this.updateCallback = updateCallback || (function() {});

    this.pointerPos = vec2.create();
    this.previousPointerPos = vec2.create();
    this._rotationVelocity = 0;
    this._combinedQuat = quat.create();
    
    this.isPointerDown = false;
    this.orientation = quat.create();
    this.pointerRotation = quat.create();
    this.rotationVelocity = 0;
    this.rotationAxis = vec3.fromValues(1, 0, 0);
    this.snapDirection = vec3.fromValues(0, 0, -1);
    this.snapTargetDirection = null;
    this.EPSILON = 0.1;
    this.IDENTITY_QUAT = quat.create();

    canvas.addEventListener("pointerdown", (e) => {
      vec2.set(this.pointerPos, e.clientX, e.clientY);
      vec2.copy(this.previousPointerPos, this.pointerPos);
      this.isPointerDown = true;
      canvas.style.cursor = "grabbing";
    });
    
    canvas.addEventListener("pointerup", () => { 
      this.isPointerDown = false;
      canvas.style.cursor = "grab";
    });
    
    canvas.addEventListener("pointerleave", () => { 
      this.isPointerDown = false;
      canvas.style.cursor = "grab";
    });
    
    canvas.addEventListener("pointermove", (e) => {
      if (this.isPointerDown) vec2.set(this.pointerPos, e.clientX, e.clientY);
    });

    canvas.style.touchAction = "none";
    canvas.style.cursor = "grab";
  }

  update(deltaTime, targetFrameDuration = 16) {
    const timeScale = deltaTime / targetFrameDuration + 0.00001;
    let angleFactor = timeScale;
    let snapRotation = quat.create();

    if (this.isPointerDown) {
      const INTENSITY = 0.3 * timeScale;
      const ANGLE_AMPLIFICATION = 5 / timeScale;

      const midPointerPos = vec2.sub(vec2.create(), this.pointerPos, this.previousPointerPos);
      vec2.scale(midPointerPos, midPointerPos, INTENSITY);

      if (vec2.sqrLen(midPointerPos) > this.EPSILON) {
        vec2.add(midPointerPos, this.previousPointerPos, midPointerPos);

        const p = this._project(midPointerPos);
        const q = this._project(this.previousPointerPos);
        const a = vec3.normalize(vec3.create(), p);
        const b = vec3.normalize(vec3.create(), q);

        vec2.copy(this.previousPointerPos, midPointerPos);

        angleFactor *= ANGLE_AMPLIFICATION;
        this.quatFromVectors(a, b, this.pointerRotation, angleFactor);
      } else {
        quat.slerp(this.pointerRotation, this.pointerRotation, this.IDENTITY_QUAT, INTENSITY);
      }
    } else {
      const INTENSITY = 0.1 * timeScale;
      quat.slerp(this.pointerRotation, this.pointerRotation, this.IDENTITY_QUAT, INTENSITY);

      if (this.snapTargetDirection) {
        const SNAPPING_INTENSITY = 0.2;
        const a = this.snapTargetDirection;
        const b = this.snapDirection;
        const sqrDist = vec3.squaredDistance(a, b);
        const distanceFactor = Math.max(0.1, 1 - sqrDist * 10);
        angleFactor *= SNAPPING_INTENSITY * distanceFactor;
        this.quatFromVectors(a, b, snapRotation, angleFactor);
      }
    }

    const combinedQuat = quat.multiply(quat.create(), snapRotation, this.pointerRotation);
    this.orientation = quat.multiply(quat.create(), combinedQuat, this.orientation);
    quat.normalize(this.orientation, this.orientation);

    const RA_INTENSITY = 0.8 * timeScale;
    quat.slerp(this._combinedQuat, this._combinedQuat, combinedQuat, RA_INTENSITY);
    quat.normalize(this._combinedQuat, this._combinedQuat);

    const rad = Math.acos(this._combinedQuat[3]) * 2.0;
    const s = Math.sin(rad / 2.0);
    let rv = 0;
    if (s > 0.000001) {
      rv = rad / (2 * Math.PI);
      this.rotationAxis[0] = this._combinedQuat[0] / s;
      this.rotationAxis[1] = this._combinedQuat[1] / s;
      this.rotationAxis[2] = this._combinedQuat[2] / s;
    }

    const RV_INTENSITY = 0.5 * timeScale;
    this._rotationVelocity += (rv - this._rotationVelocity) * RV_INTENSITY;
    this.rotationVelocity = this._rotationVelocity / timeScale;

    this.updateCallback(deltaTime);
  }

  quatFromVectors(a, b, out, angleFactor = 1) {
    const axis = vec3.cross(vec3.create(), a, b);
    vec3.normalize(axis, axis);
    const d = Math.max(-1, Math.min(1, vec3.dot(a, b)));
    const angle = Math.acos(d) * angleFactor;
    quat.setAxisAngle(out, axis, angle);
    return { q: out, axis, angle };
  }

  _project(pos) {
    const r = 2;
    const w = this.canvas.clientWidth;
    const h = this.canvas.clientHeight;
    const s = Math.max(w, h) - 1;

    const x = (2 * pos[0] - w - 1) / s;
    const y = (2 * pos[1] - h - 1) / s;
    let z = 0;
    const xySq = x * x + y * y;
    const rSq = r * r;

    if (xySq <= rSq / 2.0) {
      z = Math.sqrt(rSq - xySq);
    } else {
      z = rSq / Math.sqrt(xySq);
    }
    return vec3.fromValues(-x, y, z);
  }
}

/* =========================
   MAIN MENU ENGINE
========================= */

class InfiniteGridMenu {
  constructor(canvas, items, onActiveItemChange, onMovementChange, onInit = null, scale = 1.0) {
    this.canvas = canvas;
    this.items = items || [];
    this.onActiveItemChange = onActiveItemChange || (function() {});
    this.onMovementChange = onMovementChange || (function() {});
    this.scaleFactor = scale;
    
    this.TARGET_FRAME_DURATION = 1000 / 60;
    this.SPHERE_RADIUS = 2;
    
    this._time = 0;
    this._deltaTime = 0;
    this._deltaFrames = 0;
    this._frames = 0;
    this._stopped = false;

    this.camera = {
      matrix: mat4.create(),
      near: 0.1,
      far: 40,
      fov: Math.PI / 4,
      aspect: 1,
      position: vec3.fromValues(0, 0, 3 * scale),
      up: vec3.fromValues(0, 1, 0),
      matrices: {
        view: mat4.create(),
        projection: mat4.create(),
        inversProjection: mat4.create(),
      },
    };

    this.smoothRotationVelocity = 0;
    this.movementActive = false;

    this._initWebGL();
    if (this.gl && onInit) {
      onInit(this);
    }
  }

  _initWebGL() {
    try {
      this.gl = this.canvas.getContext("webgl2", { 
        antialias: true, 
        alpha: true,
        preserveDrawingBuffer: false,
        powerPreference: "high-performance"
      });

      if (!this.gl) {
        console.warn("WebGL2 not supported ‚Äî InfiniteMenu disabled safely");
        return;
      }

      this.discProgram = createProgram(
        this.gl,
        [discVertShaderSource, discFragShaderSource],
        null,
        {
          aModelPosition: 0,
          aModelUvs: 1,
          aInstanceMatrix: 2,
        }
      );

      if (!this.discProgram) {
        console.warn("Shader program failed ‚Äî InfiniteMenu disabled");
        this.gl = null;
        return;
      }

      this.gl.useProgram(this.discProgram);
      
      this.discLocations = {
        aModelPosition: this.gl.getAttribLocation(this.discProgram, "aModelPosition"),
        aModelUvs: this.gl.getAttribLocation(this.discProgram, "aModelUvs"),
        aInstanceMatrix: this.gl.getAttribLocation(this.discProgram, "aInstanceMatrix"),

        uWorldMatrix: this.gl.getUniformLocation(this.discProgram, "uWorldMatrix"),
        uViewMatrix: this.gl.getUniformLocation(this.discProgram, "uViewMatrix"),
        uProjectionMatrix: this.gl.getUniformLocation(this.discProgram, "uProjectionMatrix"),
        uCameraPosition: this.gl.getUniformLocation(this.discProgram, "uCameraPosition"),
        uRotationAxisVelocity: this.gl.getUniformLocation(this.discProgram, "uRotationAxisVelocity"),

        uTex: this.gl.getUniformLocation(this.discProgram, "uTex"),
        uItemCount: this.gl.getUniformLocation(this.discProgram, "uItemCount"),
        uAtlasSize: this.gl.getUniformLocation(this.discProgram, "uAtlasSize"),
      };

      this._initGeometry();
      this._initTexture();
      this.control = new ArcballControl(this.canvas, (deltaTime) => this._onControlUpdate(deltaTime));
      this._updateCameraMatrix();
      this.resize();

    } catch (error) {
      console.error("Failed to initialize WebGL:", error);
      this.gl = null;
    }
  }

  _initGeometry() {
    const gl = this.gl;
    
    this.discGeo = new DiscGeometry(56, 1);
    this.discBuffers = this.discGeo.data;

    this.discVAO = makeVertexArray(
      gl,
      [
        [makeBuffer(gl, this.discBuffers.vertices, gl.STATIC_DRAW), this.discLocations.aModelPosition, 3],
        [makeBuffer(gl, this.discBuffers.uvs, gl.STATIC_DRAW), this.discLocations.aModelUvs, 2],
      ],
      this.discBuffers.indices
    );

    this.icoGeo = new IcosahedronGeometry();
    this.icoGeo.subdivide(1).spherize(this.SPHERE_RADIUS);
    this.instancePositions = this.icoGeo.vertices.map((v) => v.position);
    this.DISC_INSTANCE_COUNT = this.icoGeo.vertices.length;

    this.worldMatrix = mat4.create();
    this._initDiscInstances();
  }

  _initTexture() {
    const gl = this.gl;
    
    this.tex = createAndSetupTexture(
      gl, 
      gl.LINEAR, 
      gl.LINEAR, 
      gl.CLAMP_TO_EDGE, 
      gl.CLAMP_TO_EDGE
    );

    const itemCount = Math.max(1, this.items.length);
    this.atlasSize = Math.ceil(Math.sqrt(itemCount));

    const placeholderSize = 512;
    const placeholderCanvas = document.createElement("canvas");
    placeholderCanvas.width = placeholderSize;
    placeholderCanvas.height = placeholderSize;
    const ctx = placeholderCanvas.getContext("2d");
    
    const gradient = ctx.createLinearGradient(0, 0, placeholderSize, placeholderSize);
    gradient.addColorStop(0, '#f1f5f9');
    gradient.addColorStop(1, '#e2e8f0');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, placeholderSize, placeholderSize);
    
    ctx.fillStyle = '#64748b';
    ctx.font = 'bold 48px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Loading...', placeholderSize/2, placeholderSize/2);
    
    gl.bindTexture(gl.TEXTURE_2D, this.tex);
    gl.texImage2D(
      gl.TEXTURE_2D,
      0,
      gl.RGBA,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      placeholderCanvas
    );
    
    if (this.items.length > 0) {
      this._loadProductImages();
    }
  }

 _loadProductImages() {
  const gl = this.gl;
  const itemCount = Math.max(1, this.items.length);
  const atlasSize = Math.ceil(Math.sqrt(itemCount));
  
  // Use larger cell size to preserve quality
  const cellSize = 1024; // Increased from 512 to preserve quality
  const totalSize = atlasSize * cellSize;

  const atlasCanvas = document.createElement("canvas");
  atlasCanvas.width = totalSize;
  atlasCanvas.height = totalSize;
  const ctx = atlasCanvas.getContext("2d");
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";

  // Create transparent background instead of white
  ctx.clearRect(0, 0, totalSize, totalSize);

  let loadedCount = 0;
  const totalItems = this.items.length;

  const loadNextImage = (index) => {
    if (index >= totalItems) {
      this._uploadTextureToGPU(atlasCanvas);
      return;
    }

    const item = this.items[index];
    const img = new Image();
    
    img.onload = () => {
      console.log(`‚úÖ Image loaded: ${item.image} (${img.width}x${img.height})`);
      
      const x = (index % atlasSize) * cellSize;
      const y = Math.floor(index / atlasSize) * cellSize;
      
      // Calculate scaling while maintaining aspect ratio
      const maxWidth = cellSize * 0.9; // 90% of cell to add padding
      const maxHeight = cellSize * 0.9;
      
      let width = img.width;
      let height = img.height;
      
      // Calculate aspect ratio
      const aspectRatio = width / height;
      
      if (width > maxWidth) {
        width = maxWidth;
        height = width / aspectRatio;
      }
      
      if (height > maxHeight) {
        height = maxHeight;
        width = height * aspectRatio;
      }
      
      // Center the image in the cell
      const offsetX = (cellSize - width) / 2;
      const offsetY = (cellSize - height) / 2;
      
      // Draw image with padding and maintaining aspect ratio
      ctx.drawImage(img, x + offsetX, y + offsetY, width, height);
      
      loadedCount++;
      loadNextImage(index + 1);
    };

    img.onerror = (err) => {
      console.warn("‚ùå Failed to load image:", item.image, err);
      
      const x = (index % atlasSize) * cellSize;
      const y = Math.floor(index / atlasSize) * cellSize;
      
      // Draw a placeholder
      ctx.fillStyle = this._getPlaceholderColor(index);
      ctx.fillRect(x, y, cellSize, cellSize);
      
      // Draw product name
      ctx.fillStyle = "#000000";
      ctx.font = "bold 32px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(item.title, x + cellSize/2, y + cellSize/2);
      
      loadedCount++;
      loadNextImage(index + 1);
    };

    let imageUrl = item.image;
    
    if (!imageUrl.startsWith('http') && !imageUrl.startsWith('/')) {
      imageUrl = '/' + imageUrl;
    }
    
    console.log("üì• Attempting to load image:", imageUrl);
    
    img.crossOrigin = "anonymous";
    img.src = imageUrl;
  };

  loadNextImage(0);
}

  _getPlaceholderColor(index) {
    const colors = [
      "#FFE5B4",
      "#FFD1DC",
      "#E6E6FA",
      "#B0E0E6",
      "#98FB98",
      "#FFDAB9",
    ];
    return colors[index % colors.length];
  }

  _uploadTextureToGPU(atlasCanvas) {
    const gl = this.gl;
    console.log("üì§ Uploading texture atlas to GPU...");
    
    gl.bindTexture(gl.TEXTURE_2D, this.tex);
    gl.texImage2D(
      gl.TEXTURE_2D,
      0,
      gl.RGBA,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      atlasCanvas
    );
    
    console.log("‚úÖ Texture atlas uploaded successfully");
    this.textureReady = true;
  }

  _initDiscInstances() {
    const gl = this.gl;
    const count = this.DISC_INSTANCE_COUNT;
    
    this.discInstances = {
      matricesArray: new Float32Array(count * 16),
      matrices: [],
      buffer: gl.createBuffer(),
    };

    for (let i = 0; i < count; ++i) {
      const instanceMatrixArray = new Float32Array(
        this.discInstances.matricesArray.buffer,
        i * 16 * 4,
        16
      );
      instanceMatrixArray.set(mat4.create());
      this.discInstances.matrices.push(instanceMatrixArray);
    }

    gl.bindVertexArray(this.discVAO);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.discInstances.buffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.discInstances.matricesArray.byteLength, gl.DYNAMIC_DRAW);

    const bytesPerMatrix = 16 * 4;
    for (let j = 0; j < 4; ++j) {
      const loc = this.discLocations.aInstanceMatrix + j;
      gl.enableVertexAttribArray(loc);
      gl.vertexAttribPointer(loc, 4, gl.FLOAT, false, bytesPerMatrix, j * 4 * 4);
      gl.vertexAttribDivisor(loc, 1);
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindVertexArray(null);
  }

  resize() {
    if (!this.gl) return;

    const needsResize = resizeCanvasToDisplaySize(this.gl.canvas);
    if (needsResize) {
      this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
    }

    this._updateProjectionMatrix();
  }

  run(time = 0) {
    if (this._stopped || !this.gl) return;

    this._deltaTime = Math.min(32, time - this._time);
    this._time = time;
    this._deltaFrames = this._deltaTime / this.TARGET_FRAME_DURATION;
    this._frames += this._deltaFrames;

    this._animate(this._deltaTime);
    this._render();

    requestAnimationFrame((t) => this.run(t));
  }

  _animate(deltaTime) {
    if (!this.gl) return;

    this.control.update(deltaTime, this.TARGET_FRAME_DURATION);

    const positions = this.instancePositions.map((p) =>
      vec3.transformQuat(vec3.create(), p, this.control.orientation)
    );
    const scale = 0.25;
    const SCALE_INTENSITY = 0.6;

    positions.forEach((p, ndx) => {
      const s = (Math.abs(p[2]) / this.SPHERE_RADIUS) * SCALE_INTENSITY + (1 - SCALE_INTENSITY);
      const finalScale = s * scale;

      const matrix = mat4.create();
      mat4.multiply(matrix, matrix, mat4.fromTranslation(mat4.create(), vec3.negate(vec3.create(), p)));
      mat4.multiply(matrix, matrix, mat4.targetTo(mat4.create(), [0, 0, 0], p, [0, 1, 0]));
      mat4.multiply(matrix, matrix, mat4.fromScaling(mat4.create(), [finalScale, finalScale, finalScale]));
      mat4.multiply(matrix, matrix, mat4.fromTranslation(mat4.create(), [0, 0, -this.SPHERE_RADIUS]));

      mat4.copy(this.discInstances.matrices[ndx], matrix);
    });

    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.discInstances.buffer);
    this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, this.discInstances.matricesArray);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);

    this.smoothRotationVelocity = this.control.rotationVelocity;
  }

  _render() {
    if (!this.gl) return;

    const gl = this.gl;

    gl.useProgram(this.discProgram);

    gl.enable(gl.CULL_FACE);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // Set uniforms with correct types
    gl.uniformMatrix4fv(this.discLocations.uWorldMatrix, false, this.worldMatrix);
    gl.uniformMatrix4fv(this.discLocations.uViewMatrix, false, this.camera.matrices.view);
    gl.uniformMatrix4fv(this.discLocations.uProjectionMatrix, false, this.camera.matrices.projection);

    gl.uniform3f(this.discLocations.uCameraPosition,
      this.camera.position[0], this.camera.position[1], this.camera.position[2]);

    gl.uniform4f(this.discLocations.uRotationAxisVelocity,
      this.control.rotationAxis[0], this.control.rotationAxis[1], this.control.rotationAxis[2],
      this.smoothRotationVelocity * 1.1);

    // FIXED: Use gl.uniform1f for float uniforms
    if (this.discLocations.uItemCount !== -1) {
      gl.uniform1f(this.discLocations.uItemCount, this.items.length || 1);
    }
    
    if (this.discLocations.uAtlasSize !== -1) {
      gl.uniform1f(this.discLocations.uAtlasSize, this.atlasSize || 1);
    }

    // Bind texture
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.tex);
    if (this.discLocations.uTex !== -1) {
      gl.uniform1i(this.discLocations.uTex, 0);
    }

    // Draw
    gl.bindVertexArray(this.discVAO);
    gl.drawElementsInstanced(
      gl.TRIANGLES,
      this.discBuffers.indices.length,
      gl.UNSIGNED_SHORT,
      0,
      this.DISC_INSTANCE_COUNT
    );

    gl.bindVertexArray(null);
  }

  _updateCameraMatrix() {
    mat4.targetTo(this.camera.matrix, this.camera.position, [0, 0, 0], this.camera.up);
    mat4.invert(this.camera.matrices.view, this.camera.matrix);
  }

  _updateProjectionMatrix() {
    if (!this.gl) return;

    const canvas = this.gl.canvas;
    this.camera.aspect = canvas.clientWidth / canvas.clientHeight;
    const height = this.SPHERE_RADIUS * 0.35;
    const distance = this.camera.position[2];

    if (this.camera.aspect > 1) {
      this.camera.fov = 2 * Math.atan(height / distance);
    } else {
      this.camera.fov = 2 * Math.atan(height / this.camera.aspect / distance);
    }

    mat4.perspective(this.camera.matrices.projection, this.camera.fov, this.camera.aspect, this.camera.near, this.camera.far);
    mat4.invert(this.camera.matrices.inversProjection, this.camera.matrices.projection);
  }

  _onControlUpdate(deltaTime) {
    if (!this.gl) return;

    const timeScale = deltaTime / this.TARGET_FRAME_DURATION + 0.0001;
    let damping = 5 / timeScale;
    let cameraTargetZ = 3 * this.scaleFactor;

    const isMoving = this.control.isPointerDown || Math.abs(this.smoothRotationVelocity) > 0.01;

    if (isMoving !== this.movementActive) {
      this.movementActive = isMoving;
      if (this.onMovementChange) {
        this.onMovementChange(isMoving);
      }
    }

    if (!this.control.isPointerDown) {
      const nearestVertexIndex = this._findNearestVertexIndex();
      const itemIndex = nearestVertexIndex % Math.max(1, this.items.length);
      if (this.onActiveItemChange) {
        this.onActiveItemChange(itemIndex);
      }

      const snapDirection = vec3.normalize(vec3.create(), this._getVertexWorldPosition(nearestVertexIndex));
      this.control.snapTargetDirection = snapDirection;
    } else {
      cameraTargetZ += this.control.rotationVelocity * 80 + 2.5;
      damping = 7 / timeScale;
    }

    this.camera.position[2] += (cameraTargetZ - this.camera.position[2]) / damping;
    this._updateCameraMatrix();
  }

  _findNearestVertexIndex() {
    const n = this.control.snapDirection;
    const inversOrientation = quat.conjugate(quat.create(), this.control.orientation);
    const nt = vec3.transformQuat(vec3.create(), n, inversOrientation);

    let maxD = -1;
    let nearestVertexIndex = 0;

    for (let i = 0; i < this.instancePositions.length; ++i) {
      const d = vec3.dot(nt, this.instancePositions[i]);
      if (d > maxD) {
        maxD = d;
        nearestVertexIndex = i;
      }
    }
    return nearestVertexIndex;
  }

  _getVertexWorldPosition(index) {
    const nearestVertexPos = this.instancePositions[index];
    return vec3.transformQuat(vec3.create(), nearestVertexPos, this.control.orientation);
  }

  stop() {
    this._stopped = true;
    try {
      if (this.gl && this.gl.getExtension("WEBGL_lose_context")) {
        this.gl.getExtension("WEBGL_lose_context").loseContext();
      }
    } catch (e) {
      // Ignore
    }
  }
}

/* =========================
   DEFAULT FALLBACK
========================= */

const defaultProducts = [
  {
    title: "Mango",
    description: "Rich Alphonso mango pulp.",
    image: "/products/mango2.png"
  },
  {
    title: "Strawberry",
    description: "Sweet-tangy strawberry pulp.",
    image: "/products/strawberry2.png"
  },
  {
    title: "Tender Coconut",
    description: "Pure tender coconut pulp.",
    image: "/products/tender-coconut1.png"
  },
  {
    title: "Chikku",
    description: "Creamy natural chikku pulp.",
    image: "/products/chikku1.png"
  },
  {
    title: "Avocado",
    description: "Smooth premium avocado pulp.",
    image: "/products/avocado1.png"
  },
  {
    title: "Custard Apple",
    description: "Exotic custard apple pulp.",
    image: "/products/custard-apple1.png"
  },
];

/* =========================
   REACT COMPONENT
========================= */

export default function InfiniteMenu({
  items = [],
  scale = 1.0,
  className = "",
}) {
  const canvasRef = useRef(null);
  const sketchRef = useRef(null);
  const resizeObserverRef = useRef(null);

  const [activeItem, setActiveItem] = useState(null);
  const [isMoving, setIsMoving] = useState(false);
  const [imagesLoaded, setImagesLoaded] = useState(false);

  const titleColors = {
    Mango: "#D1C81F",
    Strawberry: "#B40B3C",
    "Tender Coconut": "#4F6F1F",
    Chikku: "#6A3E17",
    Avocado: "#2F6B2F",
    "Custard Apple": "#2F5F1E",
  };

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    let sketch;

    const init = () => {
      if (!canvas || canvas.clientWidth === 0 || canvas.clientHeight === 0) {
        return;
      }

      const usedItems = items && items.length ? items : defaultProducts;

      const handleActiveItem = (index) => {
        const itemIndex = index % usedItems.length;
        setActiveItem(usedItems[itemIndex]);
      };

      sketch = new InfiniteGridMenu(
        canvas,
        usedItems,
        handleActiveItem,
        setIsMoving,
        (sk) => {
          if (sk && sk.gl) {
            sk.run();
          }
        },
        scale
      );

      sketchRef.current = sketch;
    };

    const timeoutId = setTimeout(init, 100);

    resizeObserverRef.current = new ResizeObserver(() => {
      if (sketchRef.current) {
        sketchRef.current.resize();
      }
    });

    resizeObserverRef.current.observe(canvas);

    return () => {
      clearTimeout(timeoutId);
      if (resizeObserverRef.current) {
        resizeObserverRef.current.disconnect();
      }
      if (sketchRef.current) {
        sketchRef.current.stop();
        sketchRef.current = null;
      }
    };
  }, [items, scale]);

  useEffect(() => {
    console.log("üìã Available images:", defaultProducts.map(p => p.image));
    
    defaultProducts.forEach(product => {
      const img = new Image();
      img.onload = () => console.log(`‚úÖ ${product.image} exists and can be loaded`);
      img.onerror = () => console.log(`‚ùå ${product.image} failed to load`);
      img.src = product.image;
    });
  }, []);

  return (
    <div className={`relative w-full h-full ${className}`}>
      <canvas
        ref={canvasRef}
        className="w-full h-full outline-none cursor-grab active:cursor-grabbing"
      />

      {activeItem && (
        <>
          <h2
            className={`
              select-none absolute
              left-1/2 -translate-x-1/2 text-center leading-none
              top-[250px] w-[92%] max-w-[420px] text-[clamp(3.6rem,10vw,3.8rem)]
              md:top-1/2 md:-translate-y-1/2 md:w-auto md:max-w-none
              md:text-[clamp(3.4rem,2vw,7rem)] md:left-[5%] md:-translate-x-0 md:text-left
              transition-all ease-[cubic-bezier(0.25,0.1,0.25,1.0)]
              ${isMoving ? "opacity-0 pointer-events-none duration-[100ms]" : "opacity-100 pointer-events-auto duration-[500ms]"}
            `}
            style={{
              fontFamily: "Amanojaku",
              color: titleColors[activeItem.title] || "#111111",
            }}
          >
            {activeItem.title}
          </h2>

          <p
            className={`
              select-none absolute left-1/2 -translate-x-1/2 text-center max-w-[28ch]
              bottom-[250px] text-[clamp(1.4rem,3.5vw,2.25rem)]
              md:bottom-auto md:top-1/2 md:-translate-y-1/2 md:left-auto md:right-[12%]
              md:translate-x-0 md:text-right md:max-w-[30ch] md:text-[clamp(1.4rem,1.1vw,1.6rem)]
              transition-all ease-[cubic-bezier(0.25,0.1,0.25,1.0)]
              ${isMoving ? "opacity-0 pointer-events-none duration-[120ms] translate-y-6 md:translate-y-0" : "opacity-100 pointer-events-auto duration-[650ms] translate-y-0"}
            `}
            style={{
              fontFamily: "Grained",
              fontWeight: 400,
              lineHeight: 1.55,
              color: "rgba(0,0,0,0.7)",
            }}
          >
            {activeItem.description}
          </p>
        </>
      )}
     
    </div>
  );
}